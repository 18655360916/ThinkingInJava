第七章 复用类

使用类而不破坏现有程序代码的两种代码重用机制.
组合: 在新类中产生现有类的对象,该方法只是复用了现有程序代码的功能,而非它的形式.
继承: 按照现有类的类型来创建新类.无需改变新有类的形式,采用现有类的形式并在其中添加代码.

如果域是一个引用,那么可以在代码的下列位置初始化引用.
1.指定初始化(构造器调用之前被初始化).
2.实例初始化块.
3.构造器中.
4.惰性初始化,正要使用这些对象之前.

即使一个类只具有包访问权限,其public main仍然是可访问的.

为了继承,一般的规则是将所有的数据成员都指定为private,将所有的方法都指定为public.

代理:我们将一个成员对象置于所要构造的类中(就像组合),但与此同时我们在新类中暴露了该成员对象的所有方法(就像继承).
使用代理(组合的一种)时,可以拥有更多的控制力,因为我们可以选择只提供在成员对象中的方法的某个子集.

执行类的所有特定的清理动作,其顺序同生成顺序相反(这就要求基类元素仍旧存活).

垃圾回收器可能永远也无法被调用,即使被调用,他也可能以任何它想要的顺序来回收对象.
最好的办法是,除了内存以外,不能依赖垃圾回收器去做任何事情,如果需要进行清理,最好是编写自己的清理方法,但不要使用finalize();

无论是在该层或者是它的基类中对方法进行定义,重载机制都可以正常工作.

组合和继承都允许在新的类中放置子对象,组合是显示地这样做,而继承则是隐式地做.
组合技术通常用于想在新类中使用现有类的功能而非它地接口这种情形.

protected也提供了包内访问权限.

向上转型是从一个较专用类型向较通用类型转换,所以总是很安全地.

用组合还是继承,一个最清晰地判断办法就是问一问自己是否需要从新类向基类进行上转型.

final数据
一个永不改变的编译器常量(static final)
一个在运行时被初始化的值,而且你不希望他被改变.

编译器常量,如果是基本数据类型,可以在编译时执行计算式,减轻了运行时地负担.
final使得引用恒定不变,一旦引用被初始化指向一个对象,就无法再把它改为指向另一个对象,然而,对象其自身确实可以被修改的.
Java并未提供使任何对象恒定不变的途径,可以自己编写类达到恒定不变的效果.这一限制同样适用于数组,它也是对象.

三种编译期数值常量:
private final int valueOne = 9;
private static final int VALUE_TWO = 99;
public static final int VALUE_THREE = 39;   最常用

空白final: private final int j;
可以做到根据对象而有所不同,却又保持其恒定不变的特性.
必须在域的定义处或者每个构造器中用表达式对final进行赋值,这正是final域在使用前总是被初始化的原因所在.

final参数列表,你可以读参数,但无法修改参数,这一特性主要用来向匿名内部类传递数据.

使用final方法的原因时防止任何继承类修改他的含义,这是出于设计的考虑,想要确保在继承中使方法行为保持不变,并且不会被覆盖.

类中所有的private方法都隐式的指定为final的,由于无法取用private方法,所以也就无法覆盖它.

覆盖只有在某方法时基类接口的一部分时才会出现,而private方法不是基类的接口的一部分.

final定义某个类时,这个类不能被继承,没有子类.
由于final类禁止继承,所以final类中所有的方法都隐式指定为是final的,因为无法覆盖它们.

java文件只在需要使用程序代码时才会被加载,类的代码在初次使用时才加载.
类是在其任何static成员(包括所有构造器)被访问时加载的.

每个类都有具体的用途
不会太大(包含太多功能而难以复用)
不会太小(不添加其他功能就无法使用)



