第10章 内部类

可以将一个类的定义放在另一个类的定义内部,这就是内部类.
内部类是一种非常有用的特性:允许把一些逻辑相关的类组织在一起,并控制位于内部的类的可视性,可以与外围类良好的通信.

内部类拥有其外围类的所有元素的访问权,不管是不是private的.
需要注意的是外围类是可以访问到内部类中private属性的.

如果嵌套类是private的,那么最好将其适配(实现)为一个接口.那么在任何地方就可以使用接口引用该对象了,而不受对象原类型不可用的束缚.

内部类对象(内部类是非static类时)只能在与其外围类的对象相关联的情况下才能被创建.
而不能够直接new A.B()这种没有提前创建A对象而直接创建B对象的方式.一般A.B的形式都用在引用上面,而不是创建对象时.
构建内部类时需要一个指向外围类对象的引用.如果编译器访问不到这个引用就会报错.

而迭代器设计模式正是利用了内部类自动拥有对其外围类所有成员的访问权.

在拥有外部类对象之前时不可能创建内部类对象的.这是因为内部类对象会暗暗地连接到创建它的外部类对象上.所以外围类的static方法内是不可以直接new内部类的.
但是如果创建的是嵌套类(静态内部类),那么它就不需要对外部类对象的引用.

在外围类的动态(对象)方法内可以直接new内部类对象,因为本身已存在外部类对象了,
但是外围类内如果是staitc方法是不可以new内部类对象的,因为外围类对象可能还未创建,导致内部类对象无法连接到它的外部类对象上.

内部类对象中的动态方法是隐式自动传递了两个参数,一个是外围类A的引用: A.this,另一个是内部类本身对象引用: this.

方法内定义的内部类只能在其作用域内使用,包括其引用以及对象的创建的语句,一旦超过了作用域之外使用就会报错.而不像成员内部类那样可以随处引用.
但是我们可以通过向上造型使用接口来引用在这些方法内部创建过的内部对象.

匿名内部类既可以扩展类,也可以实现接口,但是不能两者兼备,而且也只能实现一个接口.

如果不需要内部类对象与其外围类对象直接有联系,那么可以将内部类声明为static,这称为嵌套类.
要创建嵌套类的对象,并不需要其外围类的对象,所以不能从嵌套类对象中访问外围类对象(一定是非静态的).相当于与外围类隔绝了.
所以外围类.this这种引用便不存在了.

嵌套类的作用,如果内部类中含有static的域和方法,那么一定是嵌套类,即static class.
因为普通的内部类里面是不允许含有静态数据的.

接口内的内部类一定是嵌套类.自动是public static的内部类.

多次嵌套内部类的对象创建时,.new语法能产生正确的作用域,所以不必在调用构造器时限定类名,但是其引用需要.

为什么需要内部类?

内部类提供了某种进入其外围类的窗口.

内部类有效地实现了"多重继承",内部类允许继承多个非接口类型.

在单个外围类中,可以让多个内部类以不同的方式实现同一个接口,或继承同一个类.

闭包就是一个可调用的对,一般指实现了某接口的私有内部类.
钩子函数返回的是一个接口类型,向外提供特定的接口实现对象,且这个闭包是private的.仅仅钩子函数是public的.
钩子将闭包钩出来.

回调的价值在于它的灵活性,可以在运行时动态地决定需要调用什么方法.

模板方法:
要运用某个应用程序框架,通常是继承一个或多个类,并覆盖某些方法,在覆盖后地方法中,编写代码定制应用程序框架提供地通用解决方案.已解决特定问题.
模板方法包含算法地基本结构,并且会调用一个或多个可覆盖地方法,已完成算法地动作.
设计模式总是将变化的事物与保持不变的事物分离开.模板方法是保持不变的事物,而可覆盖的方法就是变化的事物.

内部类的构造器必须连接到指向其外围类对象的引用.所以一般禁止继承内部类.需要使用特殊的语法才行.

使用局部内部类而不适用匿名内部类的两个理由:
1. 需要不止一个该内部类的对象.
2. 需要一个已命名的构造器,对其重载.因为匿名内部类只能用于实例初始化.

内部类标识符:如果内部类是匿名的,编译器会简单的产生一个数字作为其标识符,跟在外围类标识符$的后面.