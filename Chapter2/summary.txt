第二章:一切都是对象

按址传递:形参是对实参的复制,但是对形参取内容进行赋值,同时实际上也改变了实参的值.
按值传递:形参是对实参的复制,直接在方法体内对形参赋值,是无法影响到实参的.值也可以是地址.
按址传递必须满足两个条件:传递地址,而且对地址是取内容的操作.Java中的对引用发送消息并不是取内容,,因此是按值传递的.
如果把对对象发送消息看作是取内容,按址传递则成立.
Java中的对象的操纵的标识符实际上是对象的一个引用,实际上也是一个地址.

程序存储数据的位置:
寄存器:最快的存储区,不能直接控制.

栈:RAM内存池,栈指针若向下移动,则直接分配新内存,若向上移动则释放那些内存.
创建程序时,Java系统必须知道存储在栈中的所有项的确切生命周期,以便上下移动栈指针.
对象的引用是存储在栈中的,而其关联的对象并不存储于其中.

堆:RAM内存池,存放所有的对象.编译器不需要知道存储的数据在堆里存活多长时间.
代价:用堆存储分配和清理可能比栈进行存储分配需要更多的时间.

常量存储:ROM程序代码中.

非RAM存储:独立于程序之外,且可以运行前提前存在,如流对象和持久化对象.对象转化为字节流,存储在文件中.
这种称为Java轻量级持久化,而JDBC和Hibernate这样的机制提供了更加复杂的对在数据库中存储和读取对象信息的支持.

基本类型存储在栈中,高效.
存储空间大小具有不变性.所有数值类型都有正负号.没有无符号的数值类型.

int和float的所有操作都支持的包装器类,高精度数字类型.
BigInteger支持任意精度的整数.
BigDecimal支持任何精度的定点数.

数组是一种对象.分为基本类型数组和引用数组两种.默认值是0和null.

作用域(scope)决定了在其定义的变量名的可见性和生命周期.由花括号的位置决定.在作用域里定义的基本类型或引用类型变量只可作用于作用域结束之前.
Java对象不具备和基本类型一样的生命周期.当用new创建一个Java对象时,它可以存活于作用域之外.
对象的引用是可以复制和传递的.

Java有一个垃圾回收器,,用来监视用new创建的所有对象.并辨别那些不会再引用的对象.
内存泄露问题减少,这是由于程序员忘记释放内存而产生的问题.

int x = a.f();
发送消息给a对象,a时对象,f()是消息.

包名分隔类,类分隔成员,方法分隔局部变量.但是由于作用域类内部名称可以穿透.
包名都得小写.所有的文件都能够自动存活于它们自己的名字空间内.

Java消除了所谓的向前引用的问题.包之间,类之间,成员之间都是平行的关系.

执行new来创建对象是,数据存储空间才被分配,其方法才供外界调用.

动态域:默认       域和方法必须知道与他们一起运作的已创建的特定对象.
静态域:static    域和方法不会与其所属类的对象关联在一起.即使没有创建该对象,也能够调用其域和方法.
因此静态方法在没有指明某个命名对象前不可以调用动态资源(默认域,默认方法).
静态域只有一份存储空间,全局共享.用类名进行调用可以被编译器优化.

static作用于某个字段时,肯定会改变数据创建的方式.从原先默认堆中迁移到RAM中的静态存储区了.
但作用于某个方法时,差别却没有那么大.一般static方法拿来做牧羊人的角色,负责看护与其隶属同一类型的实例群.如创建或使用该类的新对象.











