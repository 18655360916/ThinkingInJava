第八章 多态

在面向对象的程序设计语言中,多态是继数据抽象和继承之后的第三种基本特征.

多态通过分离做什么和怎么做,从另一角度将接口和实现分离开来.

封装通过合并特征和行为来创建新的数据类型,实现隐藏则通过将细节私有化把接口和实现分离开来.
而多态的作用则是消除类型之间的耦合关系.继承允许将对象视为它自己本身的类型或其基类型加以处理.
同一份代码也就可以毫无差别的运行在这些不同类型之上了.
多态也称动态绑定,后期绑定,运行时绑定.

将一个方法调用同一个方法主体关联起来被称作绑定.
后期绑定,运行时根据对象的类型进行绑定.能够在运行时判断对象的类型,从而调用恰当的方法.需要在对象中安置某种类型信息.

Java中除了static和final方法(private属于final)之外,其它所有的方法都是后期绑定.

一旦知道Java中所有的方法都是通过动态绑定实现多态这个事实后,我们就可以编写只与基类打交道的程序代码了.
发送消息给某个对象,让该对象去断定应该做什么事.

基类可以为它所有自它那里继承而来的所有导出类建立了一个公用接口.导出类为公共接口提供了单独的行为.

让我们忘记对象的具体类型吧,我们只需要知道其通用类型(基类型)就行.

我们所做的代码修改,不会对程序中其他不应受到影响的部分产生破坏,
换句话说,多态是一项让程序员将改变的事物与未变的事物分离开来的重要技术.

在导出类中中的方法,不要和基类中的private方法同名.

域的访问都是在编译期进行解析的.因此不是多态的.

如果某个方法是静态的,它的行为就不具有多态性.

如果某个方法是private,他的行为就不具有多态性.

如果某个方法是final的,它的行为就不具有多态性.

构造器是static方法,构造器不具有多态性.

导出类只能访问它自己的成员,不能访问基类中的成员(基类成员是private),只有基类的构造器才具有恰当的知识和权限来对自己的元素进行初始化.

基类初始化整体总是先于导出类初始化整体,这里的初始化整体包括默认初始化,指定初始化,初始化块,构造器初始化.
但是要注意一点,默认初始化不是按照这种顺序的,而是导出类的默认初始化优先于基类的默认初始化.

对于基类,首先对其导出类清理,然后才是基类.这是因为导出类的清理可能会调用基类中的某些方法,所以需要使基类中的构件仍起作用而不应过早地销毁他们.
一般按照创建的逆序进行销毁的.

可以跟踪所创建对象的实例数量的方法:
private static long counter = 0;
private final long id = counter++;

在构造器内唯一能够安全调用的那些方法是基类中的final方法,也适用于private方法,它们自动属于final方法.

当出现协变覆盖时,协变方法会将基类方法覆盖掉,干掉,而不允许同时存在.

组合不会强制我们的程序设计进入继承层次结构中,
而且组合更加灵活,因为它可以动态选择类型,因此也就选择了行为,相反,继承在编译时就需要知道确切类型.

状态模式:运行期可以给域切换不同的对象(这些对象有一个共同的基类),获得了动态灵活性.
用继承表达行为间的差异,并用字段表达状态上的变化.而状态的变化也就产生了行为的改变.

向上转型会丢失具体的类型信息.
而向下转型能够获取类型信息.
在运行期间对类型进行检查的行为称作,运行时类型识别RTTI.

