第一章:对象导论

人们所能解决问题的复杂性直接取决于抽象的类型和质量.
解空间:对问题建模的地方,例如计算机.
问题空间:问题存在的地方,例如一项业务.
面向对象程序设计的挑战在问题空间的元素和解空间的对象之间创建一对一的映射.

我们将问题空间中的元素及其在解空间中的表示称为对象,程序可以通过添加新类型的对象使自身适用于某个特定问题.

每个对象看起来都有点像一台微型计算机,它具有状态,还具有操作.将对象视为奇特的变量,它可以存储数据,也可以要求它在自身上执行操作.
对象具有状态,行为和标识.标识:在内存中一个对象有一个唯一的地址,是一个对立的确定的内存实体.
每个对象都有自己的由其他对象所构成的存储,即对象的组合.

程序是对象的集合,他们通过发送消息来告知彼此所要做的,把消息想象成对某个特定对象的方法的调用请求.
每个对象都有其类型,不同类型的对象之间特性的区别:可以发送什么样的消息给他.相同类型的对象可以接收相同的消息.

每个对象都有一个接口
每个对象都只能满足某些请求,这些请求由对象的接口所定义.而类型实现了接口.
向某个对象发送消息(产生请求),这个对象便知道此消息的目的,然后执行相应的程序代码.

每个对象都提供服务
将问题分解为对象集合.每个对象都可以很好地完成一项任务,但是它并不试图做更多的事.提高对象的内聚性.

被隐藏的具体实现
程序开发人员按角色分为:
类创建者:构建类,只向客户端程序员暴露必须的部分,隐藏对象内部脆弱的部分.
客户端程序员:收集各种用来实现快速应用开发的类.

访问控制的第一个存在原因就是让客户端程序员无法触及他们不应该触及的部分,帮助他们忽略服务不重要的部东西.
第二个原因是允许库设计者可以改变类内部的工作方式而不用影响到客户端程序员.

复用的具体实现
代码复用是面向对象程序设计语言所提供的最了不起的优点.
使用现有类合成新的类,如在创建一个对象过程中需要创建一个或多个成员对象,以实现想要的功能,这种构建称为组合(composition).
如果组合是动态发生的,即所依赖的对象引用是通过变量传入的,而不是写死在当前类中,这种是组合的广义情况,也称为聚合(aggregation).
组合被视为是 has-a 的拥有关系.
UML图: 复合类 ------> 已有类.

新类的成员对象引用通常都被声明为private,使得可以在运行时修改这些成员对象,以实现动态修改程序的行为.

以现有类为基础,复制它,然后添加和修改这个副本来创建新类,称为继承.当源类发生变动时,被修改的导出类也会反映出这些变动.
UML图从导出类用实心线三角空心箭头指向源类.是从具体到共有的类型层次结构.
可以创建一个源类表示系统中的核心概念,从源类导出其他多个类型,来表示核心可以被实现为不同的形式.
继承产生的导出类型与源类型具有类型等价性(向上转型).具有相同的基础接口.
有两种方法可以使基类与导出类产生差异.
在导出类中添加新方法.
改变基类方法的行为.称为覆盖(overriding).此时,我正在使用相同的接口方法,但是我想在新类型中做些不同的事情.
替换原则:可以用一个导出类对象替代一个源类对象.

伴随多态的可互转对象.多态最终使得接口的出现提供了原理支撑.
多态(相同的调用不同的运行状态,忽略类型的具体细节,仅仅和源类交互)的实现原理:
后期动态绑定:当向对象发送消息时,被调用的代码直到运行时才能确定,不需要更改调用它的方法,它就能够执行不同的代码.
Java使用一小段特殊代码来替代绝对地址的调用,这段代码在对象中存储信息来计算方法体的地址,
而前期静态绑定是提前通过编译器根据具体类型信息计算好方法体的地址,写到了ROM中,而后期动态绑定是运行之前是不知道具体类型信息的.
这样每一个对象都可以具有不同的行为表现,当向一个对象发送消息时,该对象就能够知道这条消息应该做什么.
调用代码和具体类型信息是分离的,使得可以扩展,如添加或覆盖消息.

单继承的好处:
所有对象具有一个公共的接口.
对象创建很容易,参数传递也得到了极大的简化.
垃圾回收器的实现容易的多.
保证所有对象都有类型信息,因此不会因无法确定对象的类型而陷入僵局.尤其在系统级操作如异常处理中.

容器类型:持有其他对象的引用的一种新的对象类型.List,Set,Map,队列,栈,树.
不同容器提供了不同类型的接口,提供了不同的请求.
不同的容器对于相同的操作具有不同的效率.

向上转型是安全的:类型等价性.
向下转型是不安全的.
参数化类型机制:编译器可以自动定制作用于特定类型上的类.通过参数化类型(泛型),编译器可以定制一个只接纳和取出Shape对象的容器.

对象的创建和生命期
Java完全采用了动态内存分配方式.每当需要创建新对象时,就要使用new关键字来构建此对象的动态实例.

对于允许在栈上创建对象的语言,编译器可以确定对象的存活时间,并且可以自动销毁它.
对于在堆上创建的对象,编译器就会对它的生命周期一无所知.
Java垃圾回收器被设计用来处理内存释放问题.

异常是一种对象,从出错地点被抛出,并被专门处理特定类型错误的相应的异常处理器捕获.
异常处理就像是与程序正常执行路径并行的,在错误发生时执行的另一条路径,
因为它是另一条完全分离的执行路径,所以它不会干扰正常的执行代码.
异常不能被忽略,所以它保证一定会在某处得到处理.
异常提供了一种从错误状况进行可靠恢复的途径,有助于写出更健壮的程序.

在程序中,这些彼此独立运行的部分称为线程.
在同一时刻处理多个任务称为并发.

在语言级别上,多线程所带来的便利之一时程序员不用再操心机器上是有多个处理器还是只有一个处理器,
由于程序再逻辑上被分为线程,所以如果机器拥有多个处理器,那么程序无需特殊调整也能执行的更快.

如果有多个并行任务都要访问同一项资源,那么就会出问题.
某个任务锁定某项资源,完成其任务,然后释放资源锁,使其他任务可以使用这项资源.

尽管Java对于解决传统的单机程序设计问题非常有用,
但同样重要的是,它解决了在万维网上的程序设计问题,分为客户端编程与服务器端编程.

信息存储池,用于分发信息的软件以及信息与软件所驻留的机器或机群被总称为服务器.
驻留在用户机器上的软件与服务器进行通信,以获取信息,处理信息.

保证一个客户插入的新数据不会覆盖另一个客户插入的新数据,也不会在将其添加到数据库的过程中丢失,这被称为事务处理.

中间件被用来提高可维护性.

我们在设计过程性程序时,需要中间表示形式,因为它们使用的表示术语更加面向计算机而不是你要解决的问题.
对于设计良好的面向对象程序,通过阅读它就可以很容易的理解其代码,许多问题都可以通过重用现有的类库代码而得到解决.














