第9章 接口

接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法.

我们可能会创建一个没有任何抽象方法的抽象类:一个类让其包含任何abstract方法都显得没有实际意义,而且我们也想要阻止产生这个类的任何对象.

抽象类是有构造方法的,仅仅是被其子类继承时使用super()调用的.但是自己却不能单独new.

抽象类还是很有用的重构工具,因为它们使得我们可以很容易地将公共方法沿着继承层次结构向上移动.

接口只提供了形式,而未提供任何具体实现.接口是用来建立类与类之间地协议的.
它允许人们通过创建一个能够被向上转型为多种基类的类型,来实现某种类似多重继变种的特性.

接口中所有的方法隐式都是public的,所有域隐式都是static final的.

多个不同的继承结构可以被同一个接口管理,达到完全解耦.

策略模式(状态模式):创建一个能够根据传入参数对象不同而具有不同行为的方法.
这类方法包含所要执行算法中固定不变的部分,而策略包含变化的部分.

适配器,一般A适配B,则需该适配器实现B接口,将A作为依赖注入,使用代理模式,对A进行代理操作.
将接口从具体的实现中解耦使得接口可以应用于多种不同的具体实现,因此代码也就更具有复用性.

接口根本没有任何的具体实现,也就是说,没有任何与接口相关的存储,因此无法阻止多个接口的组合.

使用接口的核心原因:
1. 为了能够向上转型为多个基类型.
2. 与使用抽象类相同:防止客户端程序员创建该类的对象.

如果知道某事物应该成为一个基类,那么第一选择应该是使它成为一个接口,而不是抽象类.

类不能多继承但是接口是允许多继承语法的.一个接口可以继承一个接口或者多个接口.

对于两个方法名称相同的方法:
如果构成重载则一定不重写,如果构成重写则一定不重载.
当然同名方法也可能既不构成重写,也不构成重载.但此时会报错,因为会将其视为重写语法冲突:存在返回值类型冲突.但如果返回值类型是协变兼容的,则视为重写.
因此在打算组合的不同接口中使用相同的方法名通常会造成代码可读性的混乱,尽量避免这种情况.

一般将方法接受指定的一个接口,聂可以用任何你想要的对象来调用我的方法,只要你的对象遵循即实现了我的接口.

我们可以在任何现有类之上添加新的接口,这意味着让方法接受接口类型,是一种让任何类都可以对该方法进行适配的方式.

因为有了enum关键字,因此使用接口来群组常量已经显得没什么意义了.

由于接口没有构造器所以接口中的域不能是空final的.

接口中的域不是接口的一部分,它们的值被存储在该接口的静态存储区域内.

private内部接口只能在定义它的类内部实现,不能在定义它的类之外被实现,因为在外部其引用无法使用,以及该接口内部所有的方法都不能使用.尽管是public的.

嵌套类或者是嵌套接口的引用只要不是有一个是private的,就可以引用,但是嵌套引用的格式是A.B.而在嵌套类内部可以直接引用.

一个private接口或private类只能存在于一个外部类中,而不能存在于外部接口中,因为接口中不允许有private的成员.
但是一个private接口或类可以在所属类被另一个public的类或接口实现或继承.但是不能被类的外部所用,将其重写是不可能的.甚至连使用都是不可能的.

当实现某个接口时并不需要实现嵌套在其内部的任何接口.而且private接口不能在定义它的类之外被实现.

其实如果将一个嵌套接口或者类修饰为private之后,在定义它的类之外,相当于这个类内部所有的方法和属性都是final的,不可被继承.因为private自带final的效果.

工厂方法传递的一定是生成好(已经new好)的对象,即调用的是工厂的创建方法,是在工厂内部创建好的对象.
而一般工厂方法有一个工厂接口,为了实现这个工厂接口中的创建方法,返回值类型也需要是对象的一个接口.
这种双接口的设计,或者说之所以不直接使用对象的接口充当方法的参数类型而用工厂接口是因为:
1. 多封装一层可以灵活的于工厂接口对话,而不是工厂的实现对话,日后方便工厂接口更换实现.
2. 可以复用代码,即工厂的实现可以被复用.
3. 可以使用匿名内部类通过lambda进行对象的创建传递.

一般的接口没有构造器,可以使用返回接口类型的静态工厂方法充当接口的构造器.

对于创建类,几乎都可以在任何时刻,都可以替代为创建一个接口和一个工厂.

回调的思想其实就是自顶向下,逐步求精的设计思想.先搭总体框架,后实现.
而工厂接口里的抽象方法其实就是一个回调方法.向上游提供了一个对象的实例化方法.

更一般的回调方法需要上游主动提供入参.

恰当的原则应该是优先选择类而不是接口,接口是一种很重要的工具,但是它们容易被滥用.